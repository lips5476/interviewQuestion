## get和post的区别
   1.get应用于对服务器不产生影响的场景下 如请求一个网页资源
     post应用于对服务器产生影响的场景下 如注册用户信息
   2.浏览器一般对get信息缓存不太对post信息缓存
   3.get的请求长度短于post请求长度因为浏览器会对url长度有限制
   4.post支持参数传递的类型更多
## put和post的区别
put请求并不会修改服务器数据类型  理解为更新数据
post请求可能会修改数据的类型创建新的内容    理解为创建数据




## http状态吗304的作用
   服务器为提高网站的访问速度会对部分已访问页面缓存 当客户端请求时  服务器会判断页面与之前是否相同
   相同返回304
   如果产生较多304
      可能是页面长期不更新或者纯html静态页面
   这可能会导致网站快照停止  权重下降
## 常见的http请求方法
   get  post delete put  option  connect。。。。

## options请求方法及使用场景
   option请求可以在请求某资源之前决定对该资源执行哪些操作(可以知道服务器端对该资源有哪些操作权限)
         也可以在请求某资源之前得知服务器端支持哪些http请求方法
   它的响应不能缓存

##  http1.0和1.1的区别
  1. 1.0非持久连接 1.1 默认使用持久连接 使多个 http 请求复用同一个 TCP 连接，避免每次建立连接造成的时延。
  2. 1.0 中，存在带宽浪费问题，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，且不支持断点续传功能，1.1 请求头引入了 range 头域，允许只请求资源的某个部分，返回码是 206 
  3. 1.1新增了host字段 用来指定服务器的域名。1.0 的 URL中不会传递主机名。因为一台物理服务器上可以存在4.多个虚拟主机共享一个IP地址。因此 host 字段，可将请求发到同一台服务器上的不同网站。
  4. 1.1新增了很多方法如 put delete 等
##  http1.1和2.0的区别
   1. 2.0是一个二进制协议 1.1中报文的头信息必须是文本  数据体文本二进制都可  2.0则必须都是二进制
   2. 2.0实现多路复用  它仍复用tcp连接 但客户端可和服务端同时可发送多个请求回应 且可无序发送解决了对头堵塞问题
   3. 2.0使用了数据流的概念 由于它的每个数据包不是按顺序发送所以每个包称为一个数据流 每个数据流都有唯一的编号用于区分它属于哪个请求
   4. 2.0用gzip或者compress对头信息进行了压缩 因为http1.0没有状态所以每次请求都附带请求信息 会导致很多字段重复 2.0服务器和客户端同时维护一张信息表生成的索引号所有字段都存入这个表 发送只发送索引号
    提高了速度
   5. 允许服务器主动未经过客户端请求向客服端推送资源 可以减少一些延迟时间


## http和https的区别
   https需要ca证书
   http是超文本传输协议 信息是明文传输的  https是被ssl加密的安全传输协议
   端口不同  https443  http80
   http协议是无状态的   https是ssl和http一起构建的加密网络协议  更安全

## get方法对url长度限制的原因 
   http协议对url长度并没有限制  这个限制是浏览器对他的限制  不同的浏览器限制不同
   因为url过长会导致浏览器无法正常工作



## 对keep-alive的理解
  1.0默认短链接 当使用keep-alive模式时可以使客户端和服务器持续连接 这就是长连接
  1.0版本默认没有keep-alive 若想保持连接 手动配置发送connection:keep-alive /connection:close
  服务器与客户端保持连接或者断开的过程主要是看是否有connection首部字段
  优点  
        允许请求和应答的http管线化
        降低了拥塞控制
        减少请求延迟
        报错了也无需关闭tcp连接
   缺点  长时间tcp连接导致资源无效占用
##  页面有多张图片  http如何加载
    http1.0 会请求多次  多域名部署解决可以提高同时请求的数量
    http2.0  一次可以请求多个资源因为它支持多路复用  即一个tcp连接发送多个http请求

## http2.0的头部压缩算法
   HPACK算法  在客户端和服务器端建立字典  用索引号表示重复的字符串 用哈夫曼编码压缩整数和字符串 可高达50-90的压缩率

##  http协议的优点和缺点
    HTTP 是超文本传输协议，定义了客户端和服务器之间交换报文的格式，默认使用 80 端口。它使用 TCP 作为传输协议，保证了数据传输的可靠性。
    优点
    支持客户端服务器模式 简单快速  短连接  无状态
    缺点
    由于无状态  服务器不保存任何客户信息
    明文传输不安全
    不验证通信方身份
    无法证明报文完整可靠(可能遭劫持篡改)
##  http3.0
    基于udp实现了类似于tcp的quic协议的功能
       包括多路复用  快速握手  流量控制  tls加密

   

## url包括哪些部分
   协议部分 域名部分  端口部分 虚拟目录部分  文件名部分 锚部分 参数部分

##  与缓存相关的http请求头有哪些
   强缓存
    expires  cache-control
   协商缓存
    etag
    if no match
    last modifiy 
    if modify since
    缓存其实是一个保存在浏览器端的资源副本

    强缓存：直接从读取缓存， 不请求服务器 ，返回的状态码是 200 。 协商缓存： 会去服务器比对 ，若没改变才直接读取本地缓存，返回的状态码是 304 


## 端口号的作用
    一台主机有对应一个Ip地址 可以提供很多服务如web ftp  但是单一个ip地址无法区分这些服务  所以需要端口号来区分

## https
   超文本安全传输协议  利用ssl/tls来加密数据包 利用http来实现通信
   主要提供对网站服务器的身份认证  保护数据安全完整

   https比http多了ssl/tls安全层来对请求的数据加密对接受的数据解密
   
   ssl/tls 依赖三种算法 散列函数hash(验证信息完整)  对称加密(协商秘钥加密数据) 非对称加密(实现身份验证和秘钥协商)


## 数字证书  
   单纯使用 非对称加密的公私钥 并不能保证安全 因为完全有可能有黑客截取了公钥 将他的公钥发了出去 而我们用它的公钥加密了发出去之后他可以用他的私钥解密  因此需要一个第三方的认证中心ca机构 将信息用它的私钥加密同时形成签名 然后两者结合在一起成为数字证书



## dns
   是域名系统
   提供的是一种主机名到 IP 地址的转换服务
   作用是将传过去的域名解析为IP地址，客户端向DNS服务器发送域名查询请求，DNS服务器告知客户机对应服务器的 IP 地址。
   DNS占用53号端口，同时使用TCP和UDP协议。
   （1）在区域传输的时候使用TCP协议
   （2）在域名解析的时候使用UDP协议
## session cookie  token
  同一个浏览器和服务器进行多次沟通叫做session(会话)
  服务器为了识别若干个请求来自哪台浏览器的会话  需要给cookie里加上一个字段sessionId
  所以session只是通过cookie里面放一个sessionId来实现的 
  session的应用就是图形验证码
  token也是存在session里的 用于对应每个用户的某种权限

Cookie是Web服务器保存在用户浏览器上的小文本文件，它可以包含有关用户的信息，是用户获取传递信息的主要场所之一

## webpack打包原理
  webpack 是一个Js应用程序的静态模块打包器  它会递归地构建一个依赖关系图 里面包含应用程序需要的每个模块,然后将这些模块打包成一个或多个 bundle



## ajax fetch axios
ajax使一种无需重新加载整个网页的情况下就能更新部分的的技术，
还可以通过与服务器进行少量数据交换使网页实现异步更新
fetch是基于promise封装的ajax的替代品 它没有使用xmlhttprequest对象
axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，本质上也是对XHR的封装

##  https握手原理
客  ——》 服     协议版本号 随机数  加密方法
服——》客        确认加密方法  随机数 证书
客 ——》服务    证书公钥加密的随机数  所有内容的hash值 
服务 ——》    用自己的私钥解密随机数   发送所有内容的hash




## 在浏览器搜索栏输入一个url到浏览器渲染环节发生什么
    网络阶段：构建请求行、查询强缓存、DNS解析、建立TCP连接、发送HTTP请求、响应请求
    解析阶段：解析html、构建dom树、计算样式、生成布局
    渲染阶段：生成图层树、生成绘制列表、生成图块、优先选择视口附近的图块生成位图数据、展示内容


## webSocket  
   WebSocket是HTML5提供的一种浏览器与服务器进行全双工通信的技术  它基于TCP传输协议，复用HTTP的握手通道。它相当于是把tcp协议的发送抽象成一个一个的消息，不需要你自己再专门去字节流里区分消息，它可以直接帮助你区分，浏览器和服务器只需一次握手，两者就可以持久性的连接， 并双向数据传输。
   服务器和客户端可以相互主动推送消息。
   它还可以防止粘包

##  什么是粘包 
     粘包主要因为接收方不知道消息之间的界限，不知一次性提取多少字节的数据所造成的。发送方引起的粘包一般是由TCP协议本身造成的，TCP为提高传输效率，发送方往往要收集到足够多的数据后才发送一个TCP段(nagle算法)。. 若连续几次需要send的数据都很少，通常TCP会根据negal优化算法把这些数据合成一个TCP段后一次发送出去，这样接收方就收到了粘包数据。

   

##  tcp  
    就是传输控制协议  它是面向连接的基于字节流的传输层协议，它抽象出来一个双向数据管道模型
    但是它是单播的只能是一对一通信 它的首部开销最小20个字节最大60个字节 主要应用于比较可靠的数据传输
    如文件传输   它主要提供这几个功能
        如流量控制
            流量控制是为了让发送方发送数据的速度不要太快，使接收方来得及接收。TCP采用大小可变的滑动窗口
            进行流量控制，窗口大小单位是字节 这里的窗口大小指的是每次传输的数据量的大小
        拥塞控制
            当网络数据量大且造成拥堵的时候，tcp可以减小网络注入数据的数量和速度以缓解拥塞控制
        快速重传
             因为tcp的下层网络(网络层)可能出现数据丢失或失序的情况 tcp会重传其认为已丢失的包

##  为什么udp不粘包
    udp是面向消息的连接udp的每一条消息应用程序都必须以消息单位提取数据不能一次提取任意字节数据
    udp有消息保护边界 每个udp包中有消息头这样对于接收端就容易区分了
